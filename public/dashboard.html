<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Airvibe | Listener Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        body { background: #000; color: white; font-family: monospace; overflow: hidden; }
        #debug-log { position: fixed; top: 0; left: 0; width: 100%; height: 120px; background: rgba(0,20,0,0.9); color: #0f0; font-size: 10px; padding: 5px; overflow-y: scroll; z-index: 9999; border-bottom: 1px solid #0f0; }
        .stat-box { border: 1px solid #333; padding: 10px; margin: 10px; border-radius: 8px; background: #111; }
        #play-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hidden { display: none !important; }
    </style>
</head>
<body class="flex flex-col h-screen pt-[130px]"> <div id="debug-log">Waiting for logs...</div>

    <div class="flex-1 overflow-y-auto p-4">
        <h1 class="text-xl font-bold text-indigo-500 mb-4">LISTENER DIAGNOSTICS</h1>
        
        <div class="stat-box">
            <div class="text-gray-500 text-xs">CONNECTION STATUS</div>
            <div id="conn-status" class="text-yellow-500 font-bold">Connecting...</div>
        </div>

        <div class="stat-box">
            <div class="text-gray-500 text-xs">DATA FLOW</div>
            <div class="flex justify-between mt-1">
                <span>Packets Received:</span>
                <span id="pkt-count" class="text-blue-400 font-bold">0</span>
            </div>
            <div class="flex justify-between">
                <span>Buffer Length:</span>
                <span id="buf-len" class="text-green-400 font-bold">0s</span>
            </div>
        </div>

        <audio id="remoteAudio" controls class="w-full mt-4"></audio>
    </div>

    <div id="play-overlay" class="hidden">
        <div class="text-4xl mb-4">ðŸ”Š</div>
        <button onclick="forcePlay()" class="px-8 py-4 bg-green-600 text-white font-bold rounded-full animate-bounce shadow-[0_0_30px_rgba(34,197,94,0.6)]">
            TAP TO HEAR AUDIO
        </button>
        <p class="mt-4 text-gray-400 text-xs text-center px-8">Browser blocked audio.<br>Tap to unlock.</p>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let mediaSource, sourceBuffer, queue = [];
        let isUpdating = false;
        let packets = 0;
        
        // ðŸ”’ LOCK: Prevents double joining
        let isConnected = false; 

        function log(msg) {
            const el = document.getElementById('debug-log');
            el.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}<br>` + el.innerHTML;
        }

        // --- 1. CONNECT & JOIN ---
        socket.on('connect', () => {
            log("âœ… Socket Connected");
            document.getElementById('conn-status').innerText = "Searching for Stream...";
            socket.emit('requestData');
        });

        socket.on('streamList', (streams) => {
            const list = Object.values(streams);
            if (list.length > 0 && !isConnected) {
                const stream = list[0];
                joinRoom(stream.id, stream.mimeType);
            }
        });

        function joinRoom(id, mimeType) {
            if (isConnected) return;
            isConnected = true; // Lock

            log(`âž¡ï¸ Joining Room: ${id.substr(0,5)}...`);
            document.getElementById('conn-status').innerText = "Joined Room (Waiting for Audio)";
            document.getElementById('conn-status').className = "text-green-500 font-bold";
            
            socket.emit('joinEvent', { targetId: id });
            initAudio(mimeType || 'audio/webm;codecs=opus');
        }

        // --- 2. AUDIO ENGINE ---
        function initAudio(mime) {
            const audio = document.getElementById('remoteAudio');
            mediaSource = new MediaSource();
            audio.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', () => {
                log(`ðŸ”“ MediaSource Open (${mime})`);
                try {
                    if (!MediaSource.isTypeSupported(mime)) mime = 'audio/mp4';
                    
                    sourceBuffer = mediaSource.addSourceBuffer(mime);
                    sourceBuffer.mode = 'sequence'; // The Stitcher Fix
                    
                    sourceBuffer.addEventListener('updateend', () => {
                        isUpdating = false;
                        if (queue.length > 0) processQueue();
                    });
                    
                    log("âœ… Buffer Ready. Waiting for Data...");
                } catch (e) {
                    log("âŒ Init Error: " + e.message);
                }
            });

            // Try to play automatically
            audio.play().then(() => {
                log("ðŸ”Š Autoplay Started!");
            }).catch(e => {
                log("âš ï¸ Autoplay Blocked - SHOWING BUTTON");
                document.getElementById('play-overlay').classList.remove('hidden');
            });

            // Monitor Buffer
            setInterval(() => {
                if (audio.buffered.length > 0) {
                    const end = audio.buffered.end(audio.buffered.length - 1);
                    const len = end - audio.currentTime;
                    document.getElementById('buf-len').innerText = len.toFixed(2) + "s";
                    
                    // Jump if stuck
                    if (len > 3) {
                        log("â© Skipping Forward (Latency Fix)");
                        audio.currentTime = end - 0.5;
                    }
                }
            }, 500);
        }

        function forcePlay() {
            const audio = document.getElementById('remoteAudio');
            audio.play();
            document.getElementById('play-overlay').classList.add('hidden');
            log("ðŸ”Š User Forced Play");
        }

        // --- 3. DATA HANDLER ---
        socket.on('audioBuffer', async (data) => {
            // Count packet
            packets++;
            document.getElementById('pkt-count').innerText = packets;
            
            // Uncommented Log for visual confirmation
            if (packets % 20 === 0) log(`ðŸ“¥ Rx Packet #${packets}`);

            if (!sourceBuffer) return;

            try {
                const buf = (data instanceof Blob) ? await data.arrayBuffer() : data;
                queue.push(buf);
                if (!isUpdating) processQueue();
            } catch (e) {
                log("Data Error: " + e.message);
            }
        });

        function processQueue() {
            if (queue.length === 0 || isUpdating || sourceBuffer.updating) return;

            try {
                isUpdating = true;
                sourceBuffer.appendBuffer(queue.shift());
            } catch (e) {
                isUpdating = false;
                if (e.name === 'QuotaExceededError') {
                    // Nuclear Cleaning
                    if (sourceBuffer.buffered.length > 0) {
                        sourceBuffer.remove(0, sourceBuffer.buffered.end(0) - 5);
                    }
                }
            }
        }
    </script>
</body>
</html>