<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Airvibe | Stable Listener</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <script>
        tailwind.config = { 
            theme: { 
                extend: { 
                    fontFamily: { sans: ['Outfit', 'sans-serif'], mono: ['JetBrains Mono', 'monospace'] },
                    colors: { bg: '#030305', surface: '#121214', primary: '#6366f1', accent: '#a855f7', success: '#22c55e' },
                    animation: { 'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                } 
            } 
        }
    </script>
    <style>
        body { background: #030305; color: white; overflow: hidden; height: 100vh; -webkit-tap-highlight-color: transparent; }
        .glass-panel { background: rgba(20, 20, 25, 0.7); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-top: 1px solid rgba(255,255,255,0.08); }
        .hide-scroll::-webkit-scrollbar { display: none; }
        
        /* Debug Console */
        #debug-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100px;
            background: rgba(0,0,0,0.8); color: lime; font-family: monospace; font-size: 10px;
            pointer-events: none; z-index: 9999; padding: 10px; overflow: hidden;
            display: none; /* Hidden by default, toggleable if needed */
        }
    </style>
</head>
<body class="flex flex-col relative">

    <div id="debug-overlay"></div>
    <audio id="remoteAudio" playsinline crossorigin="anonymous"></audio>

    <div id="start-overlay" class="fixed inset-0 z-50 bg-[#030305] flex flex-col items-center justify-center p-6 transition-opacity duration-500">
        <div class="relative mb-10">
            <div class="absolute inset-0 bg-primary/40 blur-[60px] rounded-full animate-pulse"></div>
            <div class="w-40 h-40 rounded-full border-2 border-white/10 flex items-center justify-center relative z-10 bg-surface/50 backdrop-blur-xl">
                <span class="text-5xl animate-bounce">ðŸ“¡</span>
            </div>
        </div>
        <h1 class="text-3xl font-black mb-2 tracking-tight">AIRVIBE <span class="text-primary">PRO</span></h1>
        <p class="text-gray-400 mb-10 text-center max-w-xs font-light">Stable Stream Ready.<br>Tap to Connect.</p>
        
        <button onclick="unlockAudioEngine()" class="w-full max-w-xs h-14 bg-white text-black font-bold rounded-full text-lg shadow-[0_0_40px_rgba(255,255,255,0.3)] hover:scale-105 active:scale-95 transition flex items-center justify-center gap-2">
            <span>â–¶</span> CONNECT AUDIO
        </button>
        <div id="connection-debug" class="mt-6 text-[10px] font-mono text-gray-600">Initializing...</div>
    </div>

    <div id="main-ui" class="flex-1 flex flex-col h-full opacity-0 transition-opacity duration-700 pointer-events-none">
        
        <header class="h-16 flex items-center justify-between px-6 z-20">
            <div class="flex items-center gap-3 bg-surface/80 px-4 py-2 rounded-full border border-white/5">
                <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                <div class="text-xs font-bold tracking-widest text-gray-300" id="live-status">OFFLINE</div>
            </div>
            <div class="flex items-center gap-2 px-3 py-1 rounded-full bg-white/5 border border-white/5">
                <span class="text-xs text-gray-400" id="debug-stats">0s / 0 pkt</span>
            </div>
        </header>

        <div class="flex-1 relative flex flex-col items-center justify-center">
            <canvas id="visualizer" class="absolute inset-0 w-full h-full opacity-40"></canvas>
            <div class="relative z-10 text-center p-6">
                <div class="w-48 h-48 mx-auto rounded-3xl overflow-hidden border-4 border-white/5 shadow-2xl mb-6 relative">
                    <img id="host-avatar" src="https://api.dicebear.com/7.x/avataaars/svg?seed=Airvibe" class="w-full h-full object-cover">
                </div>
                <h2 id="room-title" class="text-2xl font-bold mb-1">Searching...</h2>
                <p id="room-host" class="text-primary font-medium">@System</p>
            </div>
        </div>

        <div class="glass-panel h-[35vh] min-h-[250px] flex flex-col rounded-t-[2rem] relative z-30">
            <div class="w-full h-1 bg-white/5">
                <div id="buffer-bar" class="h-full bg-primary w-0 transition-all duration-300"></div>
            </div>
            <div id="chat-feed" class="flex-1 overflow-y-auto p-6 space-y-4 hide-scroll mask-image-gradient">
                <div class="text-center text-xs text-gray-600">Waiting for chat...</div>
            </div>
            <div class="p-4 pb-8 bg-black/20">
                <form onsubmit="sendChat(event)" class="flex gap-3">
                    <input id="chat-inp" class="flex-1 bg-white/5 border border-white/10 rounded-full px-5 h-12 text-sm text-white focus:outline-none focus:border-primary" placeholder="Message..." autocomplete="off">
                    <button class="h-12 w-12 rounded-full bg-primary text-white flex items-center justify-center shadow-lg">âž¤</button>
                </form>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        
        // --- STABILITY ENGINE VARIABLES ---
        let mediaSource, sourceBuffer;
        let isConnected = false; 
        let audioCtx, analyser;
        let packetCount = 0;
        
        // ðŸ”¥ AGGREGATOR BUFFER (The Fix)
        let chunkQueue = []; // Holds raw ArrayBuffers
        let isAppending = false;
        let bufferInterval;

        // --- LOGGING ---
        function debug(msg) {
            console.log(`[SYS] ${msg}`);
            document.getElementById('connection-debug').innerText = msg;
        }

        // --- 1. USER INTERACTION (UNLOCK) ---
        function unlockAudioEngine() {
            const audio = document.getElementById('remoteAudio');
            
            // Setup Visualizer Context
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 64;
                const source = audioCtx.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioCtx.destination);
                startVisualizer();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();

            // UI Reveal
            document.getElementById('start-overlay').classList.add('opacity-0', 'pointer-events-none');
            document.getElementById('main-ui').classList.remove('opacity-0', 'pointer-events-none');
            document.getElementById('main-ui').classList.add('opacity-100');

            // Wake up element
            audio.play().catch(e => debug("Engine awake, waiting for data..."));
        }

        // --- 2. SOCKET CONNECTION ---
        socket.on('connect', () => {
            debug("Connected to Server");
            socket.emit('requestData');
        });

        socket.on('streamList', (streams) => {
            const list = Object.values(streams);
            if (list.length > 0) {
                const stream = list[0];
                document.getElementById('room-title').innerText = stream.title;
                document.getElementById('room-host').innerText = '@' + stream.host;
                document.getElementById('host-avatar').src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${stream.host}`;
                
                if (!isConnected) joinRoom(stream.id, stream.mimeType);
            } else {
                debug("No active broadcasts.");
                document.getElementById('live-status').innerText = "OFFLINE";
                document.getElementById('status-dot').className = "w-2 h-2 rounded-full bg-red-500";
            }
        });

        function joinRoom(id, mimeType) {
            isConnected = true; 
            debug("Joining room...");
            document.getElementById('live-status').innerText = "LIVE SIGNAL";
            document.getElementById('live-status').className = "text-xs font-bold tracking-widest text-green-400";
            document.getElementById('status-dot').className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";

            socket.emit('joinEvent', { targetId: id });
            initPipeline(mimeType || 'audio/webm;codecs=opus');
        }

        // --- 3. THE "AGGREGATOR" AUDIO PIPELINE ---
        function initPipeline(mimeType) {
            const audio = document.getElementById('remoteAudio');
            
            if (mediaSource) {
                try { if (mediaSource.readyState === 'open') mediaSource.endOfStream(); } catch(e){}
            }

            mediaSource = new MediaSource();
            audio.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', () => {
                debug("Buffer Open");
                try {
                    if (!MediaSource.isTypeSupported(mimeType)) mimeType = 'audio/mp4'; 
                    
                    sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                    sourceBuffer.mode = 'sequence'; 
                    
                    sourceBuffer.addEventListener('updateend', () => { 
                        isAppending = false; 
                    });

                    // ðŸ”¥ THE AGGREGATOR LOOP (The Stability Fix)
                    // Instead of appending every packet instantly, we wait and append in chunks.
                    if (bufferInterval) clearInterval(bufferInterval);
                    bufferInterval = setInterval(processAggregatedBuffer, 500); // Run every 500ms

                } catch(e) { debug("SourceBuffer Error: " + e.message); }
            });

            // HEARTBEAT & JUMPER
            setInterval(() => {
                if (audio.buffered.length > 0) {
                    const end = audio.buffered.end(audio.buffered.length - 1);
                    const diff = end - audio.currentTime;
                    
                    // Stats Update
                    document.getElementById('debug-stats').innerText = `${diff.toFixed(1)}s / ${packetCount} pkt`;
                    const width = Math.min(100, (diff / 3) * 100);
                    document.getElementById('buffer-bar').style.width = width + '%';

                    // Jumper Logic (If stuck behind)
                    if (diff > 4) { 
                        console.log("Jumping to live...");
                        audio.currentTime = end - 0.5;
                    }
                    
                    // Force start if stopped
                    if (audio.paused && diff > 1) {
                        audio.play().catch(e => console.log("Autoplay check"));
                    }
                }
            }, 1000);
        }

        // --- 4. DATA HANDLING ---
        socket.on('audioBuffer', async (data) => {
            if (!sourceBuffer) return;
            packetCount++;
            
            try {
                const buf = (data instanceof Blob) ? await data.arrayBuffer() : data;
                chunkQueue.push(buf); // Push to waiting room
            } catch(e){}
        });

        // ðŸ”¥ THIS FUNCTION MERGES SMALL CHUNKS INTO ONE BIG BLOCK
        function processAggregatedBuffer() {
            if (chunkQueue.length === 0 || isAppending || sourceBuffer.updating) return;

            try {
                // 1. Calculate total size
                let totalLen = 0;
                for(let chunk of chunkQueue) totalLen += chunk.byteLength;

                // 2. Merge all chunks into one Uint8Array
                const merged = new Uint8Array(totalLen);
                let offset = 0;
                for(let chunk of chunkQueue) {
                    merged.set(new Uint8Array(chunk), offset);
                    offset += chunk.byteLength;
                }

                // 3. Clear Queue
                chunkQueue = [];

                // 4. Append the BIG chunk (Stable!)
                isAppending = true;
                sourceBuffer.appendBuffer(merged);

            } catch (e) {
                console.error("Append Error:", e);
                isAppending = false;
                // Nuclear Clean if stuck
                if (e.name === 'QuotaExceededError' && sourceBuffer.buffered.length > 0) {
                    sourceBuffer.remove(0, sourceBuffer.buffered.end(0) - 5);
                }
            }
        }

        // --- 5. VISUALIZER ---
        function startVisualizer() {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            
            const resize = () => { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; };
            window.addEventListener('resize', resize);
            resize();

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / bufferLength) * 2;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 255;
                    const barHeight = v * canvas.height * 0.8;
                    const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
                    gradient.addColorStop(0, 'rgba(99, 102, 241, 0.2)');
                    gradient.addColorStop(1, 'rgba(168, 85, 247, 0.8)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, (canvas.height - barHeight) / 2, barWidth, barHeight);
                    x += barWidth + 2;
                }
            }
            draw();
        }

        // --- 6. CHAT ---
        function sendChat(e) {
            e.preventDefault();
            const inp = document.getElementById('chat-inp');
            const txt = inp.value.trim();
            if(!txt || !isConnected) return;
            addChatLog('Me', txt, true);
            socket.emit('chatMessage', { room: 1, user: 'Guest', msg: txt });
            inp.value = '';
        }

        function addChatLog(user, txt, isMe) {
            const div = document.createElement('div');
            div.className = `flex ${isMe ? 'justify-end' : 'justify-start'} animate-pulse-fast`;
            div.style.animationIterationCount = "1"; 
            div.innerHTML = `
                <div class="max-w-[85%] rounded-2xl px-4 py-2 text-sm shadow-md ${isMe ? 'bg-primary text-white rounded-br-none' : 'bg-white/10 text-gray-200 rounded-bl-none'}">
                    ${!isMe ? `<div class="text-[10px] text-gray-400 mb-1 font-bold tracking-wider uppercase">${user}</div>` : ''}
                    ${txt}
                </div>`;
            const box = document.getElementById('chat-feed');
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        socket.on('chatMessage', d => { if(d.user !== 'Guest') addChatLog(d.user, d.msg, false); });
    </script>
</body>
</html>